# BIO编程

> server端的终极目标:使用尽可能少的线程,来处理尽可能多的client请求

## 模型

```txt
任何一个client_request ->	|								|		->	WorkerThread1
任何一个client_request ->	|		Acceptor Thread			|		->	WorkerThread2
任何一个client_request ->	|								|		->	WorkerThread3
```

work可不可以池话?
```txt
在阻塞模式下,使用线程池本身就是一个伪命题.
线程池原理:内部维护了一系列线程,接受到一个任务,会找到一个空闲线程去处理这个任务,处理完了,在讲这个线程返回到线程池中.
但是在阻塞模式下,需要不断的检查client是否有新的请求新的请求,也就是调用read方法,而这个方法是阻塞的,意味着,一点调用了这个方法,如果没有
读取到数据,那么这个线程会一直block那,一直等待有数据,处理完成,立刻需要下一次判断,
也就是: 使用了线程池,线程池中维护的线程数,表示可以有多少个client来连接
```

## 对应Unxi的IO模型
```txt
阶段1:其等待的时间可能是无限长的,因为一个server已经建立连接的client,可能很久都没有发送新的请求
阶段2:只是将数据从内核拷贝到用户空间,这个时间是很快的
在BIO模型中,进程是不区分两个阶段的,当成一个整体来运行(`Socket.getInputStream().read`),因此在没有数据准备好的情况下,是一直被阻塞的.

```
改进?
```
对两个阶段区分?
用一个线程专门去负责第一阶段,这个线程专门去检查哪些Client准备好了数据,然后将client过滤出来,交给work处理
而,work线程只负责第二阶段:因为第一阶段已经保证了当前处理的client肯定是有数据的,这样work线程在读取的时候,阻塞时间是很短的,
这时机上就是unix里面的IO多路复用模型.
```